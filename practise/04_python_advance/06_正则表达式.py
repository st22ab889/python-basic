"""
简单说, 正则表达式就是使用字符串定义规则，并通过规则去验证字符串是否匹配。

匹配一个字符串是否是标准邮箱格式:
    (^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$)

Python正则表达式，使用re模块，并基于re模块中三个基础方法来做正则匹配。
    re.match(匹配规则， 被匹配字符串)
        匹配字符串开头是否和指定的字符串匹配， 匹配成功返回匹配对象（包含匹配的信息），匹配不成功返回空。

    search(匹配规则， 被匹配字符串)
        搜索整个字符串，找出匹配的。从前向后，找到第一个后，就停止，不会继续向后

    findall(匹配规则， 被匹配字符串)
        匹配整个字符串，找出全部匹配项, 找不到返回一个空的List
"""

import re

# 匹配字符串的开头
str_1 = "python java c++  python docker"
result = re.match('python', str_1)
print(result)
print(result.span())
print(result.group())

result = re.search('java', str_1)
print(result)
print(result.span())
print(result.group())

result = re.findall('python', str_1)
print(result)


print('---------------------------------------------------------------------------------------------------------------')

"""
元字符匹配规则(元字符就是带有特殊功能的字符)
    单字符匹配：
        .       匹配任意1个字符(除了\n), \. 匹配点本身
        []      匹配[]中列举的字符
        \d      匹配数据, 即 0-9
        \D      匹配非数字
        \s      匹配空白,既空格、tab键
        \S      匹配非空白
        \w      匹配单词字符,既a-z、A-Z、0-9、_(下划线)
        \W      匹配非单词字符
    
    数量匹配:
        *       匹配前一个规则的字符出现0至无数次
        +       匹配前一个规则的字符出现1至无数次
        ?       匹配前一个规则的字符出现0次或1次
        {m}     匹配前一个规则的字符出现m次
        {m,}    匹配前一个规则的字符出现最少m次
        {m,n}   匹配前一个规则的字符出现m到n次. 注意：m 和 n 的前后都不要有空格
        
    边界匹配:
        ^       匹配字符串开头
        $       匹配字符串结尾
        \b      匹配一个单词的边界
        \B      匹配非单词边界
        
    分组匹配:
        |       匹配左右任意一个表达式，或的意思，要么匹配左边的，要么匹配右边的
        ()      将括号中字符作为一个分组，就是用括号括起来成为一个整体
"""

str_2 = "python2 @ @ !!569 ##java8"

# 字符串前面带上r标记, 表示字符串中转义字符无效, 就是普通字符的意思. 因为"\"在编程语言中表示转义, 比如"\n"表示换行, "\t"表示制表符
result = re.findall(r'\d', str_2)               # 找出数字
print(result)

result = re.findall(r'\W', str_2)              # 找出特殊字符
print(result)


result = re.findall(r'[a-zA-Z0-9]', str_2)     # 找出全部的英文字母和数字
print(result)

result = re.findall(r'[5-7]', str_2)           # 找出 5、6、7 三个字符
print(result)


# 只能由字母和数字组成，长度限制6到10位
r = r'^[0-9a-zA-Z]{6,10}$'
print(re.findall(r, 'asdasdfasd'))


# 匹配QQ号，要求纯数字，长度5-11，第一位不为0
r = r'^[1-9][0-9]{4,10}$'
print(re.findall(r, '4310121'))


# 匹配邮箱地址，只允许qq、163、gmail这三种邮箱地址
r = r'^[\w-]+(\.[\w-]+)*@(qq|163|gmail)(\.[\w-]+)+$'

# findall 方法有个特殊的地方在于, 如果正则表达式中有括号划分分组，就会把每个组所匹配的结果返回，而不是整体
print(re.findall(r, 'kkk_en@163.com'))   # 结果是 [('', '163', '.com')] , 因为正则表达式中有三个括号, 所以匹配出了三个结果


r = r'(^[\w-]+(\.[\w-]+)*@(qq|163|gmail)(\.[\w-]+)+$)'  # 用括号把整个正则表达式括起来作为一个整体, 能匹配到正确的结果， 但是会匹配出多余的结果
print(re.findall(r, 'kkk_en@163.com'))   # 结果为 [('kkk_en@163.com', '', '163', '.com')] ,  因为正则表达式中有四个括号, 所以匹配出了四个结果


r = r'^[\w-]+(\.[\w-]+)*@(qq|163|gmail)(\.[\w-]+)+$'
print(re.match(r, 'kkk_en@163.com').group())            # 使用 match 就能精确匹配到目标字符串，这里正则表达式可以用括号括成一个整体, 也可以不用括!
